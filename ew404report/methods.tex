\section{Materials and methods}
\label{sec:methods}

To demonstrate the objective of replicating \Canna\ display dives,  I simulated the system in \MATLAB\ and Simulink.  This was to be followed up with a proof-of-concept demonstration, provided I am able to achieve successful trials in simulation first; however, the demonstration was affected by the global COVID-19 pandemic. Simulation was used because it was more general and allowed easy changing of parameters and control methods to more completely explore the space; simulations also allowed examination of behavior at actual hummingbird flight speeds without risking excessive damage to the hardware. Simulations make simplifying assumptions by necessity, so actual testing and demonstration using real quadrotors--namely the Crazyflie 2.1--were also planned. Unfortunately, due to the inaccessibility of hardware brought about by the stay-at-home orders issued by the DoD in March of 2020, a final hardware demonstration of trajectory flight was never executed. Progress made towards achieving a hardware demonstration is described later in this report.  
% This part is way too wordy and non-sequitur. 
%Before I describe these processes, it is important to mention why these are the methods I chose to implement. A simulation is general in that I can run the simulation for many iterations to see how the controller will react to different input parameters. The input parameters themselves are very specific; however, the ability to change parameter values will allow me to assess the full capabilities of the quadrotor system to determine if I can eliminate the need to do a time-scaled comparison to the hummingbird trajectory. The simulation will be coded using MATLAB and Simulink, both are software with which I have the most experience in creating simulations. My simulation code will be made available after the completion to this project on Git for those wishing to replicate my simulated results. Unfortunately, the realism of this simulation is limited, and as a result I will have to do a proof-of-concept demonstration to truly prove the ability of the quadrotor. Being a much more specific process, it will likely vary slightly from the simulation results, and need to be tweaked based on the level of success seen in the first few trials. Ultimately, the proof-of-concept demonstration is an essential piece to this research since a simulation doesn’t have any real world application except in principle. The experiment will enlist the use of a Crazyflie quadrotor platform, and an OptiTrack motion capture system in order to gather position vs. time data. This will help ensure accuracy in the quadrotor’s trajectory and as such, provide a higher level of confidence in the experiment’s success.

For my concept demonstrations, I modeled the rigid body dynamics of the quadrotor using parameters obtained from the Bitcraze website\footnote{\url{https://wiki.bitcraze.io/misc:investigations:thrust}}, and distance measurements taken by calipers. For initial attempts at control, the hover condition was assumed. This is a control linearization region which assumes the attitude of the quadrotor is completely level, i.e. the pitch and roll angles are assumed to be approximately zero degrees during all stages of flight. A basic waypoint position controller was utilized first in order to ensure controller functionality in simulation and on the hardware itself. A PD controller was used initially for position control, as this is a ubiquitous controller well understood by students and control theorists. Initial gains were taken from the simulation \cite{hartman2014quadcopter}
%cite dch33/Quad-Sim on github (this is the 2014 one from hartman cited here) LINK: https://github.com/dch33/Quad-Sim 
 and later adjusted to fine-tune the quadrotor response. Additionally, in order to avoid an excessive attitude command in the event of large position errors, saturation limits were be placed on the attitude command of \ang{\pm 45} in order to ensure the quadrotor doesn't over-rotate and accidentally flip over. 

The functional block diagram of the overall Crazyflie control system is shown in \fref{fig:demonstration-2}. The laptop is the central node in the control scheme, obtaining position and orientation information from the OptiTrack system, and then relaying this data to the Crazyflie in addition to the next desired position on the trajectory path. The Crazyflie then conducts onboard error calculation and command processing in order to control its position in 3D space.

% the quaternion model in \cite{greiff2017modeling}. A quaternion is defined as 
%\begin{equation}
%Q = a + b i + c j + d k
%\end{equation}
%where $i$, $j$, and $k$ are imaginary unit vectors. This model also assumes a right-handed coordinate system where $i\cdot j = k$ , and the fundamental assumptions hold true -- i.e.  $i^2 = j^2 = k^2 = ijk = -1$.  I have chosen to use this model due to the limitations of the Euler model at high rotation angles. The quaternion model will be robust to these extreme angles, and is therefore better suited for my experiment. \emph{\textbf{Evangelista comment here: this is sort of strange to mention here. It's like saying I plan to use math, or matrices, or eigenvalues. Choosing to represent rotations as quaternions is a useful thing for avoiding gimbal lock associated with singularities in the Euler angle representation, but would not be considered a defining characteristic of what you plan to do, more like a low level design choice comparable to what units you use, or if you like floats or doubles.}}

\subsection{Simulation of bio-inspired dive pullout maneuvers in \Matlab}
%To create a feasible simulation for this research, I will model the Crazyflie quadrotor platform to be used in simulation. This involves determining the various thrust vectors of the motors, and the calculation of many performance metrics. Thankfully, much of this work has already been done, and I will be relying heavily on the work in \cite{cheng2016flight} to create a useful model for the quadrotor in \MATLAB\ and Simulink.
% Due to the extreme maneuvering of the quadrotor, I have chosen to use a quaternion coordinate system to describe its position, for flight control purposes only. %A quaternion is defined as a vector of one real and three imaginary vector directions, $i$, $j$, and $k$.

Using the model of the Crazyflie quadrotor described in the \lstinline{PC_Quadcopter_Simulation.slx} \MATLAB\ Simulink simulation \cite{hartman2014quadcopter}, 
%cite quadsim_68
and hummingbird trajectory data obtained from \cite{clark2009courtship}, several trajectory comparisons were conducted in the $x$, $y$, $z$ Cartesian coordinate frame between the true hummingbird trajectory (desired trajectory) and the actual flown trajectory by the simulated Crazyflie. Since the dive trajectories have little deviation in the $y$ coordinate axis, they are compared only in the $x$ and $z$ axes for all relevant error calculations. 

%I added the following bit to explain the initial conditions, but if it's too wordy or doesn't make sense here it should be moved to a spot where it makes more sense to explain this concept.
Simulations were conducted from two different initial quadcopter states. The first simulation was run with the quadcopter starting from rest on the ground. This requires the quadcopter to ascend to the top of the trajectory first and then begin the trajectory flight, which simulates what I would have to replicate for the hardware demonstration. The second initializes the quadcopter at the beginning of the hummingbird trajectory, with an initial velocity determined by calculating the instantaneous velocity of the second data point $\delta x/\delta t$, and $\delta z/\delta t$ (both $x$ and $z$ directions) of the original hummingbird trajectory, where $\delta x = x(t = t_1) - x(t = t_0)$. These velocities were then multiplied by a scale factor based on the simulation speed (e.g. the initial velocities were reduced by a factor of 20 for a simulation trajectory at 20 times reduced speed) in order to maintain a realistic starting velocity at each of the different trajectory speeds.
%end of initial conditions spiel
%The feedback diagram of this control concept is shown below in \fref{fig:demonstration-2}. In principle, a desired trajectory will be developed from a path-planning algorithm that takes in the time scaled hummingbird trajectory and calculates the idealized pitch and motor torque and speed at each time step in order to fit this trajectory with as little error as possible. This signal will be combined with some sort of inertial measurement true position feedback to produce the error signal to the onboard flight controller. The flight controller will send a signal to the motors on the quadrotor based on this error signal to come as close as possible to zero error for the next time step, and the cycle will repeat until the quadrotor has completed its maneuver. My simulation will replicate this decision-making process using numerical integration to obtain the position data for every iteration.

%this figure needs to be moved but I'm not sure how. It's printing well above the section that it's listed in here. add a [h] (for here) or move the figure around where it is in the code. 
\begin{figure}[h]
\begin{center}
\includegraphics[width=0.8\columnwidth]{\myroot/figures/FunctionalBlockDiagram_system.png}
\end{center}
\caption{Functional block diagram of the data communication flow concept for the autonomously controlled Crazyflie, with an included onboard controller feedback loop.}
\label{fig:demonstration-2}
\end{figure}

To determine the accuracy of the trial I compared the actual flight path of the quadrotor with the desired flight path, and determined a time-scaled root mean square error between the two position vs time datasets. This error was calculated using the distance formula \fref{eq:demonstration-1}:
\begin{equation}
e_p(t) = \sqrt{(x_a(t)-x_d(t))^2 + (z_a(t)-z_d(t))^2}
%\begin{bmatrix}
%x(t) \\ y(t) \\ z(t)
%\end{bmatrix}_a^2 
%-
%\begin{bmatrix}
%x(t) \\ y(t) \\ z(t)
%\end{bmatrix}_d^2
%}
\label{eq:demonstration-1}
\end{equation}
where $e_p(t)$ is the position error at a specific time step (time $t$) in the trajectory, and the subscripts $a$ and $d$ represent the actual traveled trajectory and the desired trajectory respectively. The error in the $y$ axis is omitted since the trajectory is 2D in the $x$-$z$ plane and errors in the $y$ axis are therefore negligible for a stable controller, as is assumed. The error for every time step was averaged together to determine the root mean square error of the data. Additionally, the standard deviation $\sigma$ of the position error was calculated using the \lstinline{std()} function in \MATLAB. Without any other indications, a successful trial was considered to be one with root mean square error of less than \SI{10}{\centi\meter} over the entire trajectory, and with a $\sigma$ value of less than \SI{5}{\centi\meter}. Since the hummingbird trajectory is time-scaled down to only a fraction of its true speed, the quadrotor onboard controller was responsible for marking every position at the time it is supposed to be located at that position, therefore limiting the effects that motor operation constraints, e.g. thrust saturation, as a possible source of error in the trajectory flight.






\subsection{Tuning controller gain} %TALK HERE ABOUT CONTROLLER GAIN TUNING METHODS
After the initial simulation runs, I anticipated large position errors over the trajectory flight. As such, it was desirable to tune the control gains in order to achieve a lower root mean square error. The simulation consists of two separate levels of control. The first level is a high-level (outer loop) PD controller concerning the $x$ and $y$ position of the quadcopter, and the second level is the lower-level (inner loop) PID controller that actually determines the pitch and roll angle of the quadcopter, as well as its vertical ($z$) position. The first level is a path planning step carried out among the Optitrack (sensor), control computer, and the drone.  The second level is flight stabilization (auto mode) carried out by the flight controller native onboard the drone. The output of the first level controller is factored as input into the second level controller, along with the quadcopter state. Separate control gains are used for each degree of freedom, i.e. the control gains for the pitch angle of the quadcopter are completely independent of those for the roll angle, altitude, yaw angle, etc. In all, there are eight different control gains that characterize the behavior of the quadcopter through the 2D $x$-$z$ hummingbird trajectory: the proportional and derivative control gains for the $x$ position ($K_{px}$, and $K_{dx}$), and the proportional, derivative, and integral control gains for both the pitch $\theta$ and altitude $z$ $($respectively, $K_{p\theta}$, $K_{d\theta}$, $K_{i\theta}$, $K_{pz}$, $K_{dz}$, $K_{iz}$). 

In general, the effects of changing the proportional control gain will increase the responsiveness of the system with regard to the parameter effected by the controller. As the proportional gain is increased, overcontrolling is noted as oscillations around the desired state grow with a continued gain increase. An increase in the derivative control gain will help to counterbalance this effect to improve the overall stability of the system and reduce overshoot, while an increase in the integral control gain will reduce/eliminate oscillations around the desired settling state, bringing the steady state error to zero. As such, with regard to the effect of the control gains on the simulation output, I expect that increasing both the proportional and derivative gains should help to quicken the response of the quadrotor, and achieve a smaller root mean square error when flying the desired trajectory while remaining stable.


\subsubsection{Manual gain tuning}
Several methods of gain tuning were attempted, with varying levels of success, to reduce the root mean square error of the quadrotor flight. These methods include manual gain tuning, nonlinear optimization routines, and marginal analysis. Manual gain tuning was attempted first. Initially, the proportional gain was increased separately for each of the three characteristic control loops ($x$, $z$, and $\theta$) until signs of overcontrol/instability were noticed in the response (mostly by large oscillations around the desired control point). Then the derivative control gains were increased for each of these controllers to quell the unstable oscillations. Manual gain tuning was successful at reducing the root mean square error, and the detailed/numerical results are recorded in the Results section of this report.

\subsubsection{Attempted optimization using \lstinline{fmincon}} 
After the manual gain tuning was unable to achieve the desired performance for the quadrotor, I began looking into different ways to attempt to optimize the controller gains to achieve a minimum root mean square error. I decided to use the \MATLAB\ function, \lstinline{fmincon()} to optimize the controller gains, which finds the minimum value of a constrained nonlinear multivariable function through an iterative process. Before attempting to use the function for my problem, I completed the example problem listed in the \MATLAB\ documentation for \lstinline{fmincon()} to minimize Rosenbrock's function. This test allowed me to orient myself with using the \lstinline{fmincon()} tool, and helped to build my objective function for use on my simulation. 

In defining my optimization problem, the eight characteristic control gains ($K_{px}$, $K_{dx}$, $K_{p\theta}$, $K_{d\theta}$, $K_{i\theta}$, $K_{pz}$, $K_{dz}$, and $K_{iz}$) are the decision variables, using the values I had determined during my manual gain tuning as the initial point $x0$. My output variable (what I'm trying to optimize) is the root mean square error between the desired and actual trajectory flown by the quadcopter in the simulation. My objective function was the piece that was a little less straightforward, as it required multiple lines of \MATLAB\ code to achieve. I first set up the appropriate simulation parameters based on the changes to the decision variables made by the \lstinline{fmincon()} optimization routine. Then, I ran the simulation for a set time of 20 seconds to allow sufficient time for the quadcopter to complete the trajectory flight. Following this, I had to determine the start and end points of the trajectory flight. The start point was simply the first index of the simulation output, since the quadcopter started at the top of the trajectory. The endpoint was determined by the index of the output where the commanded position at that index was the exact same as the commanded position two iterations after that point. (The simulation continues to command the last timeseries position provided by the input until the simulation time runs out, therefore a repeated position command in adjacent time steps means that the dive trajectory has ended.) Once the starting and ending index of the simulation output were determined, I was then able to use the error calculation described by \fref{eq:demonstration-1} to determine the root square error of each time step, and average these values to find the root mean square error, completing my objective function.

In my first attempts at running the optimization routine I left the decision variables only constrained by the basic requirement that they had to be nonzero and positive. The optimizer would complete the first iteration at the initial point with no problems, but as soon as it changed the gains for the second iteration, it caused the system to become unstable and the simulation crashed with multiple zero-crossing errors. In attempts to remedy this, I changed several different simulation settings to ignore zero crossing errors and change the simulation step size, all to no avail. I then tried to add constraints to the upper bound of the decision variables (they were already constrained on the lower bound to be greater than zero), in an attempt to prevent the simulation from becoming unstable while \lstinline{fmincon()} tweaked the control gains. This was successful in that the optimization routine was able to run its course; however, the result only made small changes to the initial control gains (less than a tenth of a percent change) which resulted in no significant effect on the output variable, the root mean square error. The simulation is therefore seemingly unable to support optimization routines as it is currently written.

\subsubsection{Marginal analysis... when optimization failed}
After the attempt at control gain optimization proved unsuccessful, I decided to conduct a marginal analysis in order to determine which variables would contribute most to the reduction of the root mean square error. A marginal analysis test simply makes a small change to a decision variable, and then records the overall benefit gained and cost incurred from making that small change. Running this analysis provides insight into how this current controller scheme could be tuned further to achieve greater success at flying the quadcopter through the desired trajectory. I again used the gain values obtained from manual tuning as my initial point, and wrote a \MATLAB\ script to iterate through each gain value and run the simulation on three separate cases for each: a run with the gain at the initial point, a run with the gain decreased by 5\%, and a run with the gain increased by 5\%. After each simulation, error data was collected and saved for processing. 








\subsection{Demonstration of bio-inspired dive pullout maneuver using Crazyflie quadrotor}
Hardware implementation is essential to verifying that the findings of the simulation are accurate. The path to a successful hardware demonstration was a multi-step process. We needed to test the capability of the crazyflie to operate under manual control, open loop control, and then finally introduce closed-loop control of the crazyflie using an optical motion tracking system. As such, the hardware components necessary for this experiment include a fully functional Crazyflie quadrotor (Bitcraze, Malm\"{o}, Sweden), and an OptiTrack system (NaturalPoint Inc., Corvallis, OR). The quadrotor will be the object of the experiment, and the OptiTrack system serves as a highly accurate way to obtain position data for the Crazyflie in flight. It achieves this using visual information from nearly 20 cameras staged around the outside of the testing area. Initial experimentation will be conducted indoors to minimize any aerodynamic noise, although future trials could test controller robustness by introducing environment disturbances. Several batteries for the Crazyflie are needed to ensure sufficient trial and testing periods, and approximately five OptiTrack visual markers must be affixed asymetrically\footnote{This is to clearly distinguish the rigid body axes relative to the markers to ensure proper pose readings.} on each Crazyflie drone to ensure that it is able to be detected by the OptiTrack system and that its state is measured appropriately. These marker additions will be taken into account in simulation first in order to ensure readiness to counteract any effect they may have on the dynamics of the quadrotor in the feedback loop.

As an initial test of hardware, I used the \lstinline{cfclient} software (Bitcraze, Malm\"{o}, Sweden; \url{https://github.com/bitcraze/crazyflie-clients-python}) to link to the crazyflie from a linux machine, and test manual control of the crazyflie using a Logitech USB gamepad (Logitech F310; Lausanne, Switzerland) and a Crazyradio sending velocity and thrust commands to the Crazyflie. This allowed me to gain a basic understanding of how the crazyflie communicated with the linux machine over radio control, and how this might be implemented in a python script. I then tested the motion tracking system capabilities by obtaining automatic 3D position tracking data via the OptiTrack. The OptiTrack system worked independently from this workstation, and recorded $x$, $y$, $z$ position data while logging the time $t$ that each data point was recorded at. 

%The Crazyflie was controlled manually, from a computer, using the bitcraze \lstinline{cfclient} software (Bitcraze, Malm\"{o}, Sweden; \url{https://github.com/bitcraze/crazyflie-clients-python}). To establish manual flight control, the computer was equipped with a USB gamepad (Logitech F310; Lausanne, Switzerland) and a Crazyradio sending velocity and thrust commands to the Crazyflie. The OptiTrack system worked independently from this workstation, and recorded $x$, $y$, $z$ position data while logging the time $t$ that each data point was recorded at. 

%DISCUSS FURTHER HARDWARE DEMONSTRATION HERE. HURDLES, ETC. FIND INFO IN PROGRESS FILE ON DRIVE
%In simulation, we observed that as the speed of the maneuver increased, it was more difficult for the crazyflie to fly it accurately. We wanted to test the same trajectories on hardware in order to see if the actual crazyflie would behave in a similar manner (show a similar error in trajectory flight flying at the same speeds tested in simulation). 

%NOTE: THE TeX compiler doesn't like underscores, and won't compile if you have a naked one in the text. To solve, just put a '\' in front of it and it will render the underscore '_' as just text and will compile just fine.
The next step towards a full hardware demonstration was to test autonomous control of the Crazyflie. To support this, I cloned the \lstinline{whoenig crazyflie\_ros} github repository (\url{https://github.com/whoenig/crazyflie_ros}) which utilizes a ROS framework to run multiple python and C++ scripts that send appropriate commands to the Crazyflie based on the tasking in the files that are run. The demo package of the repository contained a plethora of different example scripts and launch files that would provide the capability needed to complete the hardware testing that I desired, including options for manual joystick control, open-loop hovering control, and closed-loop control using both Vicon (Vicon Motion Capture; Oxford, UK), an optical motion tracking system, and VRPN connection to an alternate motion tracking system such as OptiTrack (Optitrack; Corvallis, OR). I progressively ran through several of the lower level control demo packages, testing first manual control with the USB gamepad using ROS, followed by open-loop control (which ultimately resulted in the Crazyflie crashing into the ceiling due to no closed-loop feedback). Through adaptation of the vrpn control demo scripts, I was able to achieve a successful implementation of a closed-loop hover at a desired 3D location. This worked similar to waypoint control, but only consisting of two waypoints (i.e. the starting and ending point). This meant that waypoint trajectory flight would be possible in the Maury lab with the provided controller. 

Unfortunately, due to the global COVID-19 pandemic, this was as much as I was able to achieve in terms of a hardware demonstration of capability. My work up to this point has been saved in a github repository (\url{https://github.com/devangel77b/marcello-2020-code}), and should be easily accessible and run-able by any student wishing to use the combined Crazyflie OptiTrack system to conduct waypoint flight hardware demonstrations. I have also left fairly detailed instructions in a Google document, which is available on the \lstinline{marcello-2020} Google Shared Drive.
